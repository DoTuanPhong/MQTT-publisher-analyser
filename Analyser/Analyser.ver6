import paho.mqtt.client as mqtt
import time
import numpy as np
from collections import deque

BROKER = 'localhost'
REQUEST_TOPICS = ['request/qos', 'request/delay', 'request/instancecount']
DELAY_VALUES = [0, 1, 2, 4]
QOS_VALUES = [0, 1, 2]
INSTANCE_COUNT_VALUES = [1, 2, 3, 4, 5]
DURATION = 60

# Data structure to hold message data
messages = deque()
first_message_time = None
last_message_time = None

def on_connect(client, userdata, flags, rc):
    # print(f"Analyser connected with result code {rc}")
    return rc == 0

def on_message(client, userdata, msg):
    global first_message_time, last_message_time
    payload = int(msg.payload.decode())
    timestamp = time.time()
    messages.append((payload, timestamp))
    # print(f"Analyser received message {payload} at {timestamp}")

    if first_message_time is None:
        first_message_time = timestamp
    last_message_time = timestamp

def send_requests(client, qos, delay, instance_count):
    # print(f"Sending requests: QoS={qos}, Delay={delay}ms, InstanceCount={instance_count}")
    client.publish('request/qos', qos)
    client.publish('request/delay', delay)
    client.publish('request/instancecount', instance_count)

def analyze_results():
    global first_message_time, last_message_time
    received_counter = len(messages)
    print(f"Received {received_counter} messages")
    if received_counter == 0:
        return {
            "total_rate": 0,
            "loss_rate": 100,
            "out_of_order_rate": 0,
            "median_gap": None
        }

    first_msg, first_timestamp = messages[0]
    print(f"First message: {first_msg} at {first_timestamp}")
    last_msg, last_timestamp = messages[-1]
    print(f"Last message: {last_msg} at {last_timestamp}")
    expected_counter = last_msg - first_msg + 1

    lost_messages = expected_counter - received_counter
    print(f"Lost messages: {lost_messages}", f"Expected messages: {expected_counter}",  f"Received messages: {received_counter}")
    loss_rate = (lost_messages / expected_counter) * 100
    print(f"Loss rate: {loss_rate}")
    messages_np = np.array(messages)
    out_of_order_count = np.sum(messages_np[1:, 0] < messages_np[:-1, 0])
    print(f"Out of order messages: {out_of_order_count}")
    out_of_order_rate = (out_of_order_count / len(messages)) * 100
    print(f"Out of order rate: {out_of_order_rate}")

    # gaps = ((messages[i][1] - messages[i-1][1]) * 1000 for i in range(1, len(messages))
    #         if messages[i][0] == messages[i-1][0] + 1)
    # median_gap = np.median(np.fromiter(gaps, float)) if gaps else None
    median_gap = 1

    first_to_last_duration = last_message_time - first_message_time if first_message_time and last_message_time else None

    return {
        "total_rate": received_counter / DURATION,
        "loss_rate": loss_rate,
        "out_of_order_rate": out_of_order_rate,
        "median_gap": median_gap,
        "first_to_last_duration": first_to_last_duration
    }

def run_test(client, pub_qos, sub_qos, delay, instance_count):
    global messages, first_message_time, last_message_time
    messages = deque()
    first_message_time = None
    last_message_time = None
    
    send_requests(client, pub_qos, delay, instance_count)
    time.sleep(DURATION)  # Extra 0 seconds to account for setup time
    
    return analyze_results()

def start_analyzer():
    client = mqtt.Client()
    client.on_connect = on_connect
    client.on_message = on_message

    client.connect(BROKER, 1883, 60)
    client.loop_start()

    results = []

    for pub_qos in QOS_VALUES:
        for sub_qos in QOS_VALUES:
            for delay in DELAY_VALUES:
                for instance_count in INSTANCE_COUNT_VALUES:
                    print(f"Subscribing with QoS {sub_qos}", f"Publishing with QoS {pub_qos}", f"Delay {delay}", f"Instance count {instance_count}")
                    client.subscribe(f'counter/+/+/+', qos=sub_qos)
                    result = run_test(client, pub_qos, sub_qos, delay, instance_count)
                    result.update({"pub_qos": pub_qos, "sub_qos": sub_qos, "delay": delay, "instance_count": instance_count})
                    results.append(result)
                    print(f"Results: {result}")
                    print(f"Unsubscribing from counter topics")
                    client.unsubscribe(f'counter/+/+/+')

    client.loop_stop()
    client.disconnect()
    
    # Print all results
    for result in results:
        print(result)

if __name__ == "__main__":
    start_analyzer()
